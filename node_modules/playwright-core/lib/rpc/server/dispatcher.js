"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DispatcherConnection = exports.DispatcherScope = exports.Dispatcher = exports.lookupNullableDispatcher = exports.existingDispatcher = exports.lookupDispatcher = exports.dispatcherSymbol = void 0;
const events_1 = require("events");
const helper_1 = require("../../helper");
const serializers_1 = require("../serializers");
exports.dispatcherSymbol = Symbol('dispatcher');
function lookupDispatcher(object) {
    const result = object[exports.dispatcherSymbol];
    helper_1.debugAssert(result);
    return result;
}
exports.lookupDispatcher = lookupDispatcher;
function existingDispatcher(object) {
    return object[exports.dispatcherSymbol];
}
exports.existingDispatcher = existingDispatcher;
function lookupNullableDispatcher(object) {
    return object ? lookupDispatcher(object) : null;
}
exports.lookupNullableDispatcher = lookupNullableDispatcher;
class Dispatcher extends events_1.EventEmitter {
    constructor(scope, object, type, initializer, isScope, guid = type + '@' + helper_1.helper.guid()) {
        super();
        this._type = type;
        this._guid = guid;
        this._object = object;
        this._scope = isScope ? scope.createChild(guid) : scope;
        scope.bind(this._guid, this);
        object[exports.dispatcherSymbol] = this;
        this._scope.sendMessageToClient(scope.guid, '__create__', { type, initializer, guid });
    }
    _dispatchEvent(method, params = {}) {
        this._scope.sendMessageToClient(this._guid, method, params);
    }
}
exports.Dispatcher = Dispatcher;
class DispatcherScope {
    constructor(connection, guid, parent) {
        this._dispatchers = new Map();
        this._children = new Set();
        this._connection = connection;
        this._parent = parent;
        this.guid = guid;
        if (parent)
            parent._children.add(this);
    }
    createChild(guid) {
        return new DispatcherScope(this._connection, guid, this);
    }
    bind(guid, arg) {
        helper_1.assert(!this._dispatchers.has(guid));
        this._dispatchers.set(guid, arg);
        this._connection._dispatchers.set(guid, arg);
    }
    dispose() {
        // Take care of hierarchy.
        for (const child of [...this._children])
            child.dispose();
        this._children.clear();
        // Delete self from scopes and objects.
        this._connection._dispatchers.delete(this.guid);
        // Delete all of the objects from connection.
        for (const guid of this._dispatchers.keys())
            this._connection._dispatchers.delete(guid);
        if (this._parent) {
            this._parent._children.delete(this);
            this._parent._dispatchers.delete(this.guid);
        }
    }
    async sendMessageToClient(guid, method, params) {
        this._connection._sendMessageToClient(guid, method, params);
    }
    _dumpScopeState(scopes) {
        const scopeState = { _guid: this.guid };
        scopeState.objects = [...this._dispatchers.keys()];
        scopes.push(scopeState);
        [...this._children].map(c => c._dumpScopeState(scopes));
        return scopeState;
    }
}
exports.DispatcherScope = DispatcherScope;
class DispatcherConnection {
    constructor() {
        this._dispatchers = new Map();
        this.onmessage = (message) => { };
        this._rootScope = new DispatcherScope(this, '');
    }
    async _sendMessageToClient(guid, method, params) {
        this.onmessage(JSON.stringify({ guid, method, params: this._replaceDispatchersWithGuids(params) }));
    }
    rootScope() {
        return this._rootScope;
    }
    async dispatch(message) {
        const parsedMessage = JSON.parse(message);
        const { id, guid, method, params } = parsedMessage;
        const dispatcher = this._dispatchers.get(guid);
        if (!dispatcher) {
            this.onmessage(JSON.stringify({ id, error: serializers_1.serializeError(new Error('Target browser or context has been closed')) }));
            return;
        }
        if (method === 'debugScopeState') {
            const dispatcherState = {};
            dispatcherState.objects = [...this._dispatchers.keys()];
            dispatcherState.scopes = [];
            this._rootScope._dumpScopeState(dispatcherState.scopes);
            this.onmessage(JSON.stringify({ id, result: dispatcherState }));
            return;
        }
        try {
            const result = await dispatcher[method](this._replaceGuidsWithDispatchers(params));
            this.onmessage(JSON.stringify({ id, result: this._replaceDispatchersWithGuids(result) }));
        }
        catch (e) {
            this.onmessage(JSON.stringify({ id, error: serializers_1.serializeError(e) }));
        }
    }
    _replaceDispatchersWithGuids(payload) {
        if (!payload)
            return payload;
        if (payload instanceof Dispatcher)
            return { guid: payload._guid };
        if (Array.isArray(payload))
            return payload.map(p => this._replaceDispatchersWithGuids(p));
        if (typeof payload === 'object') {
            const result = {};
            for (const key of Object.keys(payload))
                result[key] = this._replaceDispatchersWithGuids(payload[key]);
            return result;
        }
        return payload;
    }
    _replaceGuidsWithDispatchers(payload) {
        if (!payload)
            return payload;
        if (Array.isArray(payload))
            return payload.map(p => this._replaceGuidsWithDispatchers(p));
        if (payload.guid && this._dispatchers.has(payload.guid))
            return this._dispatchers.get(payload.guid);
        if (typeof payload === 'object') {
            const result = {};
            for (const key of Object.keys(payload))
                result[key] = this._replaceGuidsWithDispatchers(payload[key]);
            return result;
        }
        return payload;
    }
}
exports.DispatcherConnection = DispatcherConnection;
//# sourceMappingURL=dispatcher.js.map