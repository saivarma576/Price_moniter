"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeResult = exports.parseArgument = exports.JSHandleDispatcher = void 0;
const dispatcher_1 = require("./dispatcher");
const utilityScriptSerializers_1 = require("../../common/utilityScriptSerializers");
const elementHandlerDispatcher_1 = require("./elementHandlerDispatcher");
class JSHandleDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, jsHandle) {
        super(scope, jsHandle, jsHandle.asElement() ? 'elementHandle' : 'jsHandle', {
            preview: jsHandle.toString(),
        });
        jsHandle._setPreviewCallback(preview => this._dispatchEvent('previewUpdated', preview));
    }
    async evaluateExpression(params) {
        return this._object._evaluateExpression(params.expression, params.isFunction, true /* returnByValue */, parseArgument(params.arg));
    }
    async evaluateExpressionHandle(params) {
        const jsHandle = await this._object._evaluateExpression(params.expression, params.isFunction, false /* returnByValue */, parseArgument(params.arg));
        return elementHandlerDispatcher_1.createHandle(this._scope, jsHandle);
    }
    async getProperty(params) {
        const jsHandle = await this._object.getProperty(params.name);
        return elementHandlerDispatcher_1.createHandle(this._scope, jsHandle);
    }
    async getPropertyList() {
        const map = await this._object.getProperties();
        const result = [];
        for (const [name, value] of map)
            result.push({ name, value: new JSHandleDispatcher(this._scope, value) });
        return result;
    }
    async jsonValue() {
        return serializeResult(await this._object.jsonValue());
    }
    async dispose() {
        await this._object.dispose();
    }
}
exports.JSHandleDispatcher = JSHandleDispatcher;
function parseArgument(arg) {
    return utilityScriptSerializers_1.parseEvaluationResultValue(arg.value, convertDispatchersToObjects(arg.guids));
}
exports.parseArgument = parseArgument;
function serializeResult(arg) {
    return utilityScriptSerializers_1.serializeAsCallArgument(arg, value => ({ fallThrough: value }));
}
exports.serializeResult = serializeResult;
function convertDispatchersToObjects(arg) {
    if (arg === null)
        return null;
    if (Array.isArray(arg))
        return arg.map(item => convertDispatchersToObjects(item));
    if (arg instanceof JSHandleDispatcher)
        return arg._object;
    if (typeof arg === 'object') {
        const result = {};
        for (const key of Object.keys(arg))
            result[key] = convertDispatchersToObjects(arg[key]);
        return result;
    }
    return arg;
}
//# sourceMappingURL=jsHandleDispatcher.js.map