"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrameDispatcher = void 0;
const dispatcher_1 = require("./dispatcher");
const elementHandlerDispatcher_1 = require("./elementHandlerDispatcher");
const jsHandleDispatcher_1 = require("./jsHandleDispatcher");
class FrameDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, frame) {
        super(scope, frame, 'frame', {
            url: frame.url(),
            name: frame.name(),
            parentFrame: dispatcher_1.lookupNullableDispatcher(frame.parentFrame())
        });
        this._frame = frame;
    }
    static from(scope, frame) {
        const result = dispatcher_1.existingDispatcher(frame);
        return result || new FrameDispatcher(scope, frame);
    }
    async goto(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        return dispatcher_1.lookupNullableDispatcher(await target.goto(params.url, params));
    }
    async waitForLoadState(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        await target.waitForLoadState(params.state, params);
    }
    async waitForNavigation(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        return dispatcher_1.lookupNullableDispatcher(await target.waitForNavigation(params));
    }
    async frameElement() {
        return new elementHandlerDispatcher_1.ElementHandleDispatcher(this._scope, await this._frame.frameElement());
    }
    async evaluateExpression(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        return jsHandleDispatcher_1.serializeResult(await target._evaluateExpression(params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg)));
    }
    async evaluateExpressionHandle(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        return elementHandlerDispatcher_1.createHandle(this._scope, await target._evaluateExpressionHandle(params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg)));
    }
    async waitForSelector(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        return elementHandlerDispatcher_1.ElementHandleDispatcher.createNullable(this._scope, await target.waitForSelector(params.selector, params));
    }
    async dispatchEvent(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        return target.dispatchEvent(params.selector, params.type, jsHandleDispatcher_1.parseArgument(params.eventInit), params);
    }
    async evalOnSelector(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        return jsHandleDispatcher_1.serializeResult(await target._$evalExpression(params.selector, params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg)));
    }
    async evalOnSelectorAll(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        return jsHandleDispatcher_1.serializeResult(await target._$$evalExpression(params.selector, params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg)));
    }
    async querySelector(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        return elementHandlerDispatcher_1.ElementHandleDispatcher.createNullable(this._scope, await target.$(params.selector));
    }
    async querySelectorAll(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        const elements = await target.$$(params.selector);
        return elements.map(e => new elementHandlerDispatcher_1.ElementHandleDispatcher(this._scope, e));
    }
    async content() {
        return await this._frame.content();
    }
    async setContent(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        await target.setContent(params.html, params);
    }
    async addScriptTag(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        return new elementHandlerDispatcher_1.ElementHandleDispatcher(this._scope, await target.addScriptTag(params));
    }
    async addStyleTag(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        return new elementHandlerDispatcher_1.ElementHandleDispatcher(this._scope, await target.addStyleTag(params));
    }
    async click(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        await target.click(params.selector, params);
    }
    async dblclick(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        await target.dblclick(params.selector, params);
    }
    async fill(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        await target.fill(params.selector, params.value, params);
    }
    async focus(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        await target.focus(params.selector, params);
    }
    async textContent(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        return await target.textContent(params.selector, params);
    }
    async innerText(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        return await target.innerText(params.selector, params);
    }
    async innerHTML(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        return await target.innerHTML(params.selector, params);
    }
    async getAttribute(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        return await target.getAttribute(params.selector, params.name, params);
    }
    async hover(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        await target.hover(params.selector, params);
    }
    async selectOption(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        return target.selectOption(params.selector, elementHandlerDispatcher_1.convertSelectOptionValues(params.values), params);
    }
    async setInputFiles(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        await target.setInputFiles(params.selector, params.files.map(f => ({ name: f.name, mimeType: f.mimeType, buffer: Buffer.from(f.buffer, 'base64') })), params);
    }
    async type(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        await target.type(params.selector, params.text, params);
    }
    async press(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        await target.press(params.selector, params.key, params);
    }
    async check(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        await target.check(params.selector, params);
    }
    async uncheck(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        await target.uncheck(params.selector, params);
    }
    async waitForFunction(params) {
        const target = params.isPage ? this._frame._page : this._frame;
        return elementHandlerDispatcher_1.createHandle(this._scope, await target._waitForFunctionExpression(params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg), params));
    }
    async title() {
        return await this._frame.title();
    }
}
exports.FrameDispatcher = FrameDispatcher;
//# sourceMappingURL=frameDispatcher.js.map