"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BindingCallDispatcher = exports.WorkerDispatcher = exports.PageDispatcher = void 0;
const events_1 = require("../../events");
const dispatcher_1 = require("./dispatcher");
const serializers_1 = require("../serializers");
const consoleMessageDispatcher_1 = require("./consoleMessageDispatcher");
const dialogDispatcher_1 = require("./dialogDispatcher");
const downloadDispatcher_1 = require("./downloadDispatcher");
const frameDispatcher_1 = require("./frameDispatcher");
const networkDispatchers_1 = require("./networkDispatchers");
const jsHandleDispatcher_1 = require("./jsHandleDispatcher");
const elementHandlerDispatcher_1 = require("./elementHandlerDispatcher");
class PageDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, page) {
        super(scope, page, 'page', {
            mainFrame: frameDispatcher_1.FrameDispatcher.from(scope, page.mainFrame()),
            viewportSize: page.viewportSize()
        });
        this._page = page;
        page.on(events_1.Events.Page.Close, () => this._dispatchEvent('close'));
        page.on(events_1.Events.Page.Console, message => this._dispatchEvent('console', new consoleMessageDispatcher_1.ConsoleMessageDispatcher(this._scope, message)));
        page.on(events_1.Events.Page.Crash, () => this._dispatchEvent('crash'));
        page.on(events_1.Events.Page.DOMContentLoaded, () => this._dispatchEvent('domcontentloaded'));
        page.on(events_1.Events.Page.Dialog, dialog => this._dispatchEvent('dialog', new dialogDispatcher_1.DialogDispatcher(this._scope, dialog)));
        page.on(events_1.Events.Page.Download, dialog => this._dispatchEvent('download', new downloadDispatcher_1.DownloadDispatcher(this._scope, dialog)));
        page.on(events_1.Events.Page.FileChooser, (fileChooser) => this._dispatchEvent('fileChooser', {
            element: new elementHandlerDispatcher_1.ElementHandleDispatcher(this._scope, fileChooser.element()),
            isMultiple: fileChooser.isMultiple()
        }));
        page.on(events_1.Events.Page.FrameAttached, frame => this._onFrameAttached(frame));
        page.on(events_1.Events.Page.FrameDetached, frame => this._onFrameDetached(frame));
        page.on(events_1.Events.Page.FrameNavigated, frame => this._onFrameNavigated(frame));
        page.on(events_1.Events.Page.Load, () => this._dispatchEvent('load'));
        page.on(events_1.Events.Page.PageError, error => this._dispatchEvent('pageError', { error: serializers_1.serializeError(error) }));
        page.on(events_1.Events.Page.Popup, page => this._dispatchEvent('popup', dispatcher_1.lookupDispatcher(page)));
        page.on(events_1.Events.Page.Request, request => this._dispatchEvent('request', networkDispatchers_1.RequestDispatcher.from(this._scope, request)));
        page.on(events_1.Events.Page.RequestFailed, (request) => this._dispatchEvent('requestFailed', {
            request: networkDispatchers_1.RequestDispatcher.from(this._scope, request),
            failureText: request._failureText
        }));
        page.on(events_1.Events.Page.RequestFinished, request => this._dispatchEvent('requestFinished', networkDispatchers_1.RequestDispatcher.from(scope, request)));
        page.on(events_1.Events.Page.Response, response => this._dispatchEvent('response', new networkDispatchers_1.ResponseDispatcher(this._scope, response)));
        page.on(events_1.Events.Page.Worker, worker => this._dispatchEvent('worker', new WorkerDispatcher(this._scope, worker)));
    }
    async setDefaultNavigationTimeoutNoReply(params) {
        this._page.setDefaultNavigationTimeout(params.timeout);
    }
    async setDefaultTimeoutNoReply(params) {
        this._page.setDefaultTimeout(params.timeout);
    }
    async opener() {
        return dispatcher_1.lookupNullableDispatcher(await this._page.opener());
    }
    async exposeBinding(params) {
        await this._page.exposeBinding(params.name, (source, ...args) => {
            const bindingCall = new BindingCallDispatcher(this._scope, params.name, source, args);
            this._dispatchEvent('bindingCall', bindingCall);
            return bindingCall.promise();
        });
    }
    async setExtraHTTPHeaders(params) {
        await this._page.setExtraHTTPHeaders(params.headers);
    }
    async reload(params) {
        return dispatcher_1.lookupNullableDispatcher(await this._page.reload(params));
    }
    async goBack(params) {
        return dispatcher_1.lookupNullableDispatcher(await this._page.goBack(params));
    }
    async goForward(params) {
        return dispatcher_1.lookupNullableDispatcher(await this._page.goForward(params));
    }
    async emulateMedia(params) {
        await this._page.emulateMedia(params);
    }
    async setViewportSize(params) {
        await this._page.setViewportSize(params.viewportSize);
    }
    async addInitScript(params) {
        await this._page._addInitScriptExpression(params.source);
    }
    async setNetworkInterceptionEnabled(params) {
        if (!params.enabled) {
            await this._page.unroute('**/*');
            return;
        }
        this._page.route('**/*', (route, request) => {
            this._dispatchEvent('route', { route: new networkDispatchers_1.RouteDispatcher(this._scope, route), request: networkDispatchers_1.RequestDispatcher.from(this._scope, request) });
        });
    }
    async screenshot(params) {
        return (await this._page.screenshot(params)).toString('base64');
    }
    async close(params) {
        await this._page.close(params);
    }
    async setFileChooserInterceptedNoReply(params) {
    }
    async title() {
        return await this._page.title();
    }
    async keyboardDown(params) {
        await this._page.keyboard.down(params.key);
    }
    async keyboardUp(params) {
        await this._page.keyboard.up(params.key);
    }
    async keyboardInsertText(params) {
        await this._page.keyboard.insertText(params.text);
    }
    async keyboardType(params) {
        await this._page.keyboard.type(params.text, params);
    }
    async keyboardPress(params) {
        await this._page.keyboard.press(params.key, params);
    }
    async mouseMove(params) {
        await this._page.mouse.move(params.x, params.y, params);
    }
    async mouseDown(params) {
        await this._page.mouse.down(params);
    }
    async mouseUp(params) {
        await this._page.mouse.up(params);
    }
    async mouseClick(params) {
        await this._page.mouse.click(params.x, params.y, params);
    }
    async accessibilitySnapshot(params) {
        return await this._page.accessibility.snapshot({
            interestingOnly: params.interestingOnly,
            root: params.root ? params.root._elementHandle : undefined
        });
    }
    async pdf(params) {
        if (!this._page.pdf)
            throw new Error('PDF generation is only supported for Headless Chromium');
        const binary = await this._page.pdf(params);
        return binary.toString('base64');
    }
    _onFrameAttached(frame) {
        this._dispatchEvent('frameAttached', frameDispatcher_1.FrameDispatcher.from(this._scope, frame));
    }
    _onFrameNavigated(frame) {
        this._dispatchEvent('frameNavigated', { frame: dispatcher_1.lookupDispatcher(frame), url: frame.url(), name: frame.name() });
    }
    _onFrameDetached(frame) {
        this._dispatchEvent('frameDetached', dispatcher_1.lookupDispatcher(frame));
    }
}
exports.PageDispatcher = PageDispatcher;
class WorkerDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, worker) {
        super(scope, worker, 'worker', {
            url: worker.url()
        });
        worker.on(events_1.Events.Worker.Close, () => this._dispatchEvent('close'));
    }
    async evaluateExpression(params) {
        return jsHandleDispatcher_1.serializeResult(await this._object._evaluateExpression(params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg)));
    }
    async evaluateExpressionHandle(params) {
        return elementHandlerDispatcher_1.createHandle(this._scope, await this._object._evaluateExpressionHandle(params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg)));
    }
}
exports.WorkerDispatcher = WorkerDispatcher;
class BindingCallDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, name, source, args) {
        super(scope, {}, 'bindingCall', {
            frame: dispatcher_1.lookupDispatcher(source.frame),
            name,
            args
        });
        this._promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    promise() {
        return this._promise;
    }
    resolve(params) {
        this._resolve(params.result);
    }
    reject(params) {
        this._reject(serializers_1.parseError(params.error));
    }
}
exports.BindingCallDispatcher = BindingCallDispatcher;
//# sourceMappingURL=pageDispatcher.js.map