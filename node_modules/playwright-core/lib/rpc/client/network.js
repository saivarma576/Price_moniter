"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Response = exports.Route = exports.Request = void 0;
const url_1 = require("url");
const channelOwner_1 = require("./channelOwner");
const frame_1 = require("./frame");
const serializers_1 = require("../serializers");
class Request extends channelOwner_1.ChannelOwner {
    constructor(scope, guid, initializer) {
        super(scope, guid, initializer);
        this._redirectedFrom = null;
        this._redirectedTo = null;
        this._failureText = null;
        this._redirectedFrom = Request.fromNullable(initializer.redirectedFrom);
        if (this._redirectedFrom)
            this._redirectedFrom._redirectedTo = this;
    }
    static from(request) {
        return request._object;
    }
    static fromNullable(request) {
        return request ? Request.from(request) : null;
    }
    url() {
        return this._initializer.url;
    }
    resourceType() {
        return this._initializer.resourceType;
    }
    method() {
        return this._initializer.method;
    }
    postData() {
        return this._initializer.postData;
    }
    postDataJSON() {
        if (!this._initializer.postData)
            return null;
        const contentType = this.headers()['content-type'];
        if (!contentType)
            return null;
        if (contentType === 'application/x-www-form-urlencoded') {
            const entries = {};
            const parsed = new url_1.URLSearchParams(this._initializer.postData);
            for (const [k, v] of parsed.entries())
                entries[k] = v;
            return entries;
        }
        return JSON.parse(this._initializer.postData);
    }
    headers() {
        return { ...this._initializer.headers };
    }
    async response() {
        return Response.fromNullable(await this._channel.response());
    }
    frame() {
        return frame_1.Frame.from(this._initializer.frame);
    }
    isNavigationRequest() {
        return this._initializer.isNavigationRequest;
    }
    redirectedFrom() {
        return this._redirectedFrom;
    }
    redirectedTo() {
        return this._redirectedTo;
    }
    failure() {
        if (this._failureText === null)
            return null;
        return {
            errorText: this._failureText
        };
    }
}
exports.Request = Request;
class Route extends channelOwner_1.ChannelOwner {
    static from(route) {
        return route._object;
    }
    constructor(scope, guid, initializer) {
        super(scope, guid, initializer);
    }
    request() {
        return Request.from(this._initializer.request);
    }
    async abort(errorCode = 'failed') {
        await this._channel.abort({ errorCode });
    }
    async fulfill(response) {
        const normalized = await serializers_1.normalizeFulfillParameters(response);
        await this._channel.fulfill({ response: normalized });
    }
    async continue(overrides = {}) {
        await this._channel.continue({ overrides });
    }
}
exports.Route = Route;
class Response extends channelOwner_1.ChannelOwner {
    static from(response) {
        return response._object;
    }
    static fromNullable(response) {
        return response ? Response.from(response) : null;
    }
    constructor(scope, guid, initializer) {
        super(scope, guid, initializer);
    }
    url() {
        return this._initializer.url;
    }
    ok() {
        return this._initializer.status === 0 || (this._initializer.status >= 200 && this._initializer.status <= 299);
    }
    status() {
        return this._initializer.status;
    }
    statusText() {
        return this._initializer.statusText;
    }
    headers() {
        return { ...this._initializer.headers };
    }
    async finished() {
        return await this._channel.finished();
    }
    async body() {
        return Buffer.from(await this._channel.body(), 'base64');
    }
    async text() {
        const content = await this.body();
        return content.toString('utf8');
    }
    async json() {
        const content = await this.text();
        return JSON.parse(content);
    }
    request() {
        return Request.from(this._initializer.request);
    }
    frame() {
        return Request.from(this._initializer.request).frame();
    }
}
exports.Response = Response;
//# sourceMappingURL=network.js.map