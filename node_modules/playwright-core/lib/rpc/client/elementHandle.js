"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertSelectOptionValues = exports.ElementHandle = void 0;
const frame_1 = require("./frame");
const jsHandle_1 = require("./jsHandle");
class ElementHandle extends jsHandle_1.JSHandle {
    constructor(scope, guid, initializer) {
        super(scope, guid, initializer);
        this._elementChannel = this._channel;
    }
    static from(handle) {
        return handle._object;
    }
    static fromNullable(handle) {
        return handle ? ElementHandle.from(handle) : null;
    }
    asElement() {
        return this;
    }
    async ownerFrame() {
        return frame_1.Frame.fromNullable(await this._elementChannel.ownerFrame());
    }
    async contentFrame() {
        return frame_1.Frame.fromNullable(await this._elementChannel.contentFrame());
    }
    async getAttribute(name) {
        return await this._elementChannel.getAttribute({ name });
    }
    async textContent() {
        return await this._elementChannel.textContent();
    }
    async innerText() {
        return await this._elementChannel.innerText();
    }
    async innerHTML() {
        return await this._elementChannel.innerHTML();
    }
    async dispatchEvent(type, eventInit = {}) {
        await this._elementChannel.dispatchEvent({ type, eventInit });
    }
    async scrollIntoViewIfNeeded(options = {}) {
        await this._elementChannel.scrollIntoViewIfNeeded(options);
    }
    async hover(options = {}) {
        await this._elementChannel.hover(options);
    }
    async click(options = {}) {
        return await this._elementChannel.click(options);
    }
    async dblclick(options = {}) {
        return await this._elementChannel.dblclick(options);
    }
    async selectOption(values, options = {}) {
        return await this._elementChannel.selectOption({ values: convertSelectOptionValues(values), ...options });
    }
    async fill(value, options = {}) {
        return await this._elementChannel.fill({ value, ...options });
    }
    async selectText(options) {
        await this._elementChannel.selectText(options);
    }
    async setInputFiles(files, options = {}) {
        await this._elementChannel.setInputFiles({ files, ...options });
    }
    async focus() {
        await this._elementChannel.focus();
    }
    async type(text, options = {}) {
        await this._elementChannel.type({ text, ...options });
    }
    async press(key, options = {}) {
        await this._elementChannel.press({ key, ...options });
    }
    async check(options = {}) {
        return await this._elementChannel.check(options);
    }
    async uncheck(options = {}) {
        return await this._elementChannel.uncheck(options);
    }
    async boundingBox() {
        return await this._elementChannel.boundingBox();
    }
    async screenshot(options = {}) {
        return Buffer.from(await this._elementChannel.screenshot(options), 'base64');
    }
    async $(selector) {
        return ElementHandle.fromNullable(await this._elementChannel.querySelector({ selector }));
    }
    async $$(selector) {
        return (await this._elementChannel.querySelectorAll({ selector })).map(h => ElementHandle.from(h));
    }
    async $eval(selector, pageFunction, arg) {
        return jsHandle_1.parseResult(await this._elementChannel.evalOnSelector({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: jsHandle_1.serializeArgument(arg) }));
    }
    async $$eval(selector, pageFunction, arg) {
        return jsHandle_1.parseResult(await this._elementChannel.evalOnSelectorAll({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: jsHandle_1.serializeArgument(arg) }));
    }
}
exports.ElementHandle = ElementHandle;
function convertSelectOptionValues(values) {
    if (values instanceof ElementHandle)
        return values._elementChannel;
    if (Array.isArray(values) && values.length && values[0] instanceof ElementHandle)
        return values.map((v) => v._elementChannel);
    return values;
}
exports.convertSelectOptionValues = convertSelectOptionValues;
//# sourceMappingURL=elementHandle.js.map