"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseResult = exports.serializeArgument = exports.JSHandle = void 0;
const channelOwner_1 = require("./channelOwner");
const utilityScriptSerializers_1 = require("../../common/utilityScriptSerializers");
class JSHandle extends channelOwner_1.ChannelOwner {
    constructor(scope, guid, initializer) {
        super(scope, guid, initializer);
        this._preview = this._initializer.preview;
        this._channel.on('previewUpdated', preview => this._preview = preview);
    }
    static from(handle) {
        return handle._object;
    }
    static fromNullable(handle) {
        return handle ? JSHandle.from(handle) : null;
    }
    async evaluate(pageFunction, arg) {
        return parseResult(await this._channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: serializeArgument(arg) }));
    }
    async evaluateHandle(pageFunction, arg) {
        const handleChannel = await this._channel.evaluateExpressionHandle({ expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: serializeArgument(arg) });
        return JSHandle.from(handleChannel);
    }
    async getProperty(name) {
        const handleChannel = await this._channel.getProperty({ name });
        return JSHandle.from(handleChannel);
    }
    async getProperties() {
        const map = new Map();
        for (const { name, value } of await this._channel.getPropertyList())
            map.set(name, JSHandle.from(value));
        return map;
    }
    async jsonValue() {
        return parseResult(await this._channel.jsonValue());
    }
    asElement() {
        return null;
    }
    async dispose() {
        return await this._channel.dispose();
    }
    toString() {
        return this._preview;
    }
}
exports.JSHandle = JSHandle;
function serializeArgument(arg) {
    const guids = [];
    const pushHandle = (guid) => {
        guids.push({ guid });
        return guids.length - 1;
    };
    const value = utilityScriptSerializers_1.serializeAsCallArgument(arg, value => {
        if (value instanceof channelOwner_1.ChannelOwner)
            return { h: pushHandle(value.guid) };
        return { fallThrough: value };
    });
    return { value, guids };
}
exports.serializeArgument = serializeArgument;
function parseResult(arg) {
    return utilityScriptSerializers_1.parseEvaluationResultValue(arg, []);
}
exports.parseResult = parseResult;
//# sourceMappingURL=jsHandle.js.map