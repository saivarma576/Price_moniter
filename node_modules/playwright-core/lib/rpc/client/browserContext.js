"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserContext = void 0;
const page_1 = require("./page");
const network = require("./network");
const channelOwner_1 = require("./channelOwner");
const helper_1 = require("../../helper");
const events_1 = require("../../events");
const timeoutSettings_1 = require("../../timeoutSettings");
class BrowserContext extends channelOwner_1.ChannelOwner {
    constructor(scope, guid, initializer) {
        super(scope, guid, initializer, true);
        this._pages = new Set();
        this._routes = [];
        this._bindings = new Map();
        this._pendingWaitForEvents = new Map();
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
        initializer.pages.map(p => {
            const page = page_1.Page.from(p);
            this._pages.add(page);
            page._setBrowserContext(this);
        });
        this._channel.on('bindingCall', bindingCall => this._onBinding(page_1.BindingCall.from(bindingCall)));
        this._channel.on('close', () => this._onClose());
        this._channel.on('page', page => this._onPage(page_1.Page.from(page)));
        this._channel.on('route', ({ route, request }) => this._onRoute(network.Route.from(route), network.Request.from(request)));
    }
    static from(context) {
        return context._object;
    }
    static fromNullable(context) {
        return context ? BrowserContext.from(context) : null;
    }
    _onPage(page) {
        page._setBrowserContext(this);
        this._pages.add(page);
        this.emit(events_1.Events.BrowserContext.Page, page);
    }
    _onRoute(route, request) {
        for (const { url, handler } of this._routes) {
            if (helper_1.helper.urlMatches(request.url(), url)) {
                handler(route, request);
                return;
            }
        }
        route.continue();
    }
    async _onBinding(bindingCall) {
        const func = this._bindings.get(bindingCall._initializer.name);
        if (!func)
            return;
        bindingCall.call(func);
    }
    setDefaultNavigationTimeout(timeout) {
        this._channel.setDefaultNavigationTimeoutNoReply({ timeout });
    }
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({ timeout });
    }
    pages() {
        return [...this._pages];
    }
    async newPage() {
        if (this._ownerPage)
            throw new Error('Please use browser.newContext()');
        return page_1.Page.from(await this._channel.newPage());
    }
    async cookies(urls) {
        if (!urls)
            urls = [];
        if (urls && typeof urls === 'string')
            urls = [urls];
        return this._channel.cookies({ urls: urls });
    }
    async addCookies(cookies) {
        await this._channel.addCookies({ cookies });
    }
    async clearCookies() {
        await this._channel.clearCookies();
    }
    async grantPermissions(permissions, options) {
        await this._channel.grantPermissions({ permissions, ...options });
    }
    async clearPermissions() {
        await this._channel.clearPermissions();
    }
    async setGeolocation(geolocation) {
        await this._channel.setGeolocation({ geolocation });
    }
    async setExtraHTTPHeaders(headers) {
        await this._channel.setExtraHTTPHeaders({ headers });
    }
    async setOffline(offline) {
        await this._channel.setOffline({ offline });
    }
    async setHTTPCredentials(httpCredentials) {
        await this._channel.setHTTPCredentials({ httpCredentials });
    }
    async addInitScript(script, arg) {
        const source = await helper_1.helper.evaluationScript(script, arg);
        await this._channel.addInitScript({ source });
    }
    async exposeBinding(name, binding) {
        for (const page of this.pages()) {
            if (page._bindings.has(name))
                throw new Error(`Function "${name}" has been already registered in one of the pages`);
        }
        if (this._bindings.has(name))
            throw new Error(`Function "${name}" has been already registered`);
        this._bindings.set(name, binding);
        await this._channel.exposeBinding({ name });
    }
    async exposeFunction(name, playwrightFunction) {
        await this.exposeBinding(name, (source, ...args) => playwrightFunction(...args));
    }
    async route(url, handler) {
        this._routes.push({ url, handler });
        if (this._routes.length === 1)
            await this._channel.setNetworkInterceptionEnabled({ enabled: true });
    }
    async unroute(url, handler) {
        this._routes = this._routes.filter(route => route.url !== url || (handler && route.handler !== handler));
        if (this._routes.length === 0)
            await this._channel.setNetworkInterceptionEnabled({ enabled: false });
    }
    async waitForEvent(event, optionsOrPredicate) {
        const hasTimeout = optionsOrPredicate && !(optionsOrPredicate instanceof Function);
        let reject;
        const result = await Promise.race([
            page_1.waitForEvent(this, event, optionsOrPredicate, this._timeoutSettings.timeout(hasTimeout ? optionsOrPredicate : {})),
            new Promise((f, r) => { reject = r; this._pendingWaitForEvents.set(reject, event); })
        ]);
        this._pendingWaitForEvents.delete(reject);
        return result;
    }
    async _onClose() {
        if (this._browser)
            this._browser._contexts.delete(this);
        for (const [listener, event] of this._pendingWaitForEvents) {
            if (event === events_1.Events.BrowserContext.Close)
                continue;
            listener(new Error('Context closed'));
        }
        this._pendingWaitForEvents.clear();
        this.emit(events_1.Events.BrowserContext.Close);
        this._scope.dispose();
    }
    async close() {
        await this._channel.close();
    }
}
exports.BrowserContext = BrowserContext;
//# sourceMappingURL=browserContext.js.map