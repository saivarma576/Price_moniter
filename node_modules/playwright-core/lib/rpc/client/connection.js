"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionScope = exports.Connection = void 0;
const browser_1 = require("./browser");
const browserContext_1 = require("./browserContext");
const browserType_1 = require("./browserType");
const channelOwner_1 = require("./channelOwner");
const elementHandle_1 = require("./elementHandle");
const frame_1 = require("./frame");
const jsHandle_1 = require("./jsHandle");
const network_1 = require("./network");
const page_1 = require("./page");
const worker_1 = require("./worker");
const debug = require("debug");
const consoleMessage_1 = require("./consoleMessage");
const dialog_1 = require("./dialog");
const download_1 = require("./download");
const serializers_1 = require("../serializers");
const browserServer_1 = require("./browserServer");
class Connection {
    constructor() {
        this._objects = new Map();
        this._waitingForObject = new Map();
        this.onmessage = (message) => { };
        this._lastId = 0;
        this._callbacks = new Map();
        this._scopes = new Map();
        this._rootScript = this.createScope('');
    }
    async waitForObjectWithKnownName(guid) {
        if (this._objects.has(guid))
            return this._objects.get(guid);
        return new Promise(f => this._waitingForObject.set(guid, f));
    }
    async sendMessageToServer(message) {
        const id = ++this._lastId;
        const converted = { id, ...message, params: this._replaceChannelsWithGuids(message.params) };
        debug('pw:channel:command')(converted);
        this.onmessage(JSON.stringify(converted));
        return new Promise((resolve, reject) => this._callbacks.set(id, { resolve, reject }));
    }
    _debugScopeState() {
        const scopeState = {};
        scopeState.objects = [...this._objects.keys()];
        scopeState.scopes = [...this._scopes.values()].map(scope => ({
            _guid: scope._guid,
            objects: [...scope._objects.keys()]
        }));
        return scopeState;
    }
    dispatch(message) {
        const parsedMessage = JSON.parse(message);
        const { id, guid, method, params, result, error } = parsedMessage;
        if (id) {
            debug('pw:channel:response')(parsedMessage);
            const callback = this._callbacks.get(id);
            this._callbacks.delete(id);
            if (error)
                callback.reject(serializers_1.parseError(error));
            else
                callback.resolve(this._replaceGuidsWithChannels(result));
            return;
        }
        debug('pw:channel:event')(parsedMessage);
        if (method === '__create__') {
            const scope = this._scopes.get(guid);
            scope.createRemoteObject(params.type, params.guid, params.initializer);
            return;
        }
        const object = this._objects.get(guid);
        object._channel.emit(method, this._replaceGuidsWithChannels(params));
    }
    _replaceChannelsWithGuids(payload) {
        if (!payload)
            return payload;
        if (Array.isArray(payload))
            return payload.map(p => this._replaceChannelsWithGuids(p));
        if (payload._object instanceof channelOwner_1.ChannelOwner)
            return { guid: payload._object.guid };
        if (typeof payload === 'object') {
            const result = {};
            for (const key of Object.keys(payload))
                result[key] = this._replaceChannelsWithGuids(payload[key]);
            return result;
        }
        return payload;
    }
    _replaceGuidsWithChannels(payload) {
        if (!payload)
            return payload;
        if (Array.isArray(payload))
            return payload.map(p => this._replaceGuidsWithChannels(p));
        if (payload.guid && this._objects.has(payload.guid))
            return this._objects.get(payload.guid)._channel;
        if (typeof payload === 'object') {
            const result = {};
            for (const key of Object.keys(payload))
                result[key] = this._replaceGuidsWithChannels(payload[key]);
            return result;
        }
        return payload;
    }
    createScope(guid) {
        const scope = new ConnectionScope(this, guid);
        this._scopes.set(guid, scope);
        return scope;
    }
}
exports.Connection = Connection;
class ConnectionScope {
    constructor(connection, guid) {
        this._objects = new Map();
        this._children = new Set();
        this._connection = connection;
        this._guid = guid;
    }
    createChild(guid) {
        const scope = this._connection.createScope(guid);
        this._children.add(scope);
        scope._parent = this;
        return scope;
    }
    dispose() {
        // Take care of hierarchy.
        for (const child of [...this._children])
            child.dispose();
        this._children.clear();
        // Delete self from scopes and objects.
        this._connection._scopes.delete(this._guid);
        this._connection._objects.delete(this._guid);
        // Delete all of the objects from connection.
        for (const guid of this._objects.keys())
            this._connection._objects.delete(guid);
        // Clean up from parent.
        if (this._parent) {
            this._parent._objects.delete(this._guid);
            this._parent._children.delete(this);
        }
    }
    async sendMessageToServer(message) {
        return this._connection.sendMessageToServer(message);
    }
    createRemoteObject(type, guid, initializer) {
        let result;
        initializer = this._connection._replaceGuidsWithChannels(initializer);
        switch (type) {
            case 'bindingCall':
                result = new page_1.BindingCall(this, guid, initializer);
                break;
            case 'browser':
                result = new browser_1.Browser(this, guid, initializer);
                break;
            case 'browserServer':
                result = new browserServer_1.BrowserServer(this, guid, initializer);
                break;
            case 'browserType':
                result = new browserType_1.BrowserType(this, guid, initializer);
                break;
            case 'context':
                result = new browserContext_1.BrowserContext(this, guid, initializer);
                break;
            case 'consoleMessage':
                result = new consoleMessage_1.ConsoleMessage(this, guid, initializer);
                break;
            case 'dialog':
                result = new dialog_1.Dialog(this, guid, initializer);
                break;
            case 'download':
                result = new download_1.Download(this, guid, initializer);
                break;
            case 'elementHandle':
                result = new elementHandle_1.ElementHandle(this, guid, initializer);
                break;
            case 'frame':
                result = new frame_1.Frame(this, guid, initializer);
                break;
            case 'jsHandle':
                result = new jsHandle_1.JSHandle(this, guid, initializer);
                break;
            case 'page':
                result = new page_1.Page(this, guid, initializer);
                break;
            case 'request':
                result = new network_1.Request(this, guid, initializer);
                break;
            case 'response':
                result = new network_1.Response(this, guid, initializer);
                break;
            case 'route':
                result = new network_1.Route(this, guid, initializer);
                break;
            case 'worker':
                result = new worker_1.Worker(this, guid, initializer);
                break;
            default:
                throw new Error('Missing type ' + type);
        }
        this._connection._objects.set(guid, result);
        this._objects.set(guid, result);
        const callback = this._connection._waitingForObject.get(guid);
        if (callback) {
            callback(result);
            this._connection._waitingForObject.delete(guid);
        }
        return result;
    }
}
exports.ConnectionScope = ConnectionScope;
//# sourceMappingURL=connection.js.map